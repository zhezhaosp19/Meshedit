<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2020</h1>
<h1 align="middle">Project 2: Mesh Editor</h1>
<h2 align="middle">YOUR NAME, CS184-Zhe Zhao</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>The project I implemented aim to linear interpolate Bezier Curves and Bezier Surface by control points. Also, I learn how to flip and split edges in order to upsampling meshes and make the meshes smoother and render better with shadows. The project gives me a more deep understanding of the engineering logic behind graphis.</p>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

<p><b>De Casteljau’s algorithm</b> is a recursive method to evaluate linear interpolations in Bezier Curve. Bezier curve is defined by <b>N+1</b> control points. There is a single parameter <b>t</b>, ranging between 0 and 1. Finding <b>N</b> intermediate control points in <b>N</b> segments using linear interpolations based on <b>t</b>, and then I find <b>N-1</b> intermediate control points in <b>N-1</b> segments in the next level. I repeat the steps recursively until only 1 intermediate control point can be found. One smooth curve is generated by these control points of different levels.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task1/0.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task1/1.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task1/2.jpg" align="middle" width="300px"/>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/task1/3.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task1/4.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task1/5.jpg" align="middle" width="300px"/>
      </td>
    </tr>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <video align="middle" width="900px" controls>
          <source src="images/task1/Screen Recording 2020-02-26 at 3.11.08 PM.mp4" type=video/mp4>
        </video>
        <figcaption align="middle">The video shows how Bezier Curve changes when changing the control points and t values</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

<p>In order to evaluate the points lies on the Bezier Surface, I evaluate the Bezier Surface with <b>De Casteljau’s algorithm</b> firstly which is similar to what I did in part1. </p>
<p>The control points of Bezier Surface is a <b>M x N</b> grid, each row of the control points in the grid generates a Bezier Surface based on the parameter <b>u</b>. After that, I select the point on each Bezier Surface at the same <b>v</b> coordinate by <b>BezierPatch::evaluate1D()</b> function which calls <b>BezierPatch::evaluateStep()</b> recursively and get the final single control point. I use <b>De Casteljau’s algorithm</b> to evaluate point <b>v</b> on the moving curve generated by these points. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task2/1.jpg" align="middle" width="900px"/>
        <figcaption align="middle">Bezier Surface of Teapot.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

<p>In this part, I compute the vertex normal vectors of the mesh in order to provides better shading for the surface smooth.
</p>
<p>Firstly, I initialize a vector for storing the sum of normal. </p>
<p>Secondly, I select a half-edge connected with the vertex and traverse to the twin edge of this half-edge by using the <b>twin()</b> pointer. I compute the area-weighted normal vector of the face connected with the twin edge and add it to the initialized vector. By looping this process, I am able to iterate all the normal vectors of the faces and add them together.  </p>
<p>Finally, I normalize the result. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task3/1.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Bezier Surface of Teapot.</figcaption>
      </td>
      <td>
        <img src="images/task3/2.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Smoother surface of Teapot.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 4: Half-edge flip</h3>

<p>Firstly, I list all the existing pointers of <b>half-edges</b>, <b>vertices</b>, <b>edges</b> and <b>faces</b> of the meshes. </p>
<p>Secondly, I check whether the half-edges are on the boundary, if yes, I return these edges immediately.</p>
<p>Thirdly, I reset all the half-edge pointers to the updated edges, vertices and faces after remeshing with <b>Halfedge::setNeighbors()</b> function and also update the half-edges of vertices, edges and faces if they are changed.
</p>
<p>I finish part4 very successfully without debugging.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task4/1.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Bezier Surface of Teapot.</figcaption>
      </td>
      <td>
        <img src="images/task4/2.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Bezier Surface of Teapot after Flipping.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 5: Half-edge split</h3>

<p>Firstly, similar to what I did in Part 4, I list all the existing pointers and check whether half-edges are on the boundary.</p>
<p>Secondly, since after splitting the meshes, there are new half-edges, edges, vertices and faces and they are initialized.</p>
<p>Thirdly, I reset the pointers with <b>Halfedge::setNeighbors()</b> function as I did in the part 4.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task5/1.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Bezier Surface of Teapot.</figcaption>
      </td>
      <td>
        <img src="images/task5/2.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Bezier Surface of Teapot after Splitting.</figcaption>
      </td>
    </tr>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task5/3.jpg" align="middle" width="400px"/>
        <figcaption align="middle">Bezier Surface of Teapot after Flipping and Also Splitting.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>The main bug I have is that although I set the half-edge of the new vertex to the new half-edge, I don’t set the position of it. Therefore, when I am going to split the edge, the face will disappear.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task5/debug.jpg" align="middle" width="900px"/>
        <figcaption align="middle">Bug: The Sample of the Mesh Disappear.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>

<p>Loop Subdivision provides a data structure to smooth the sharp meshes.
</p>
<p>Firstly, I calculate the position of the new vertex following <b>3/8 * (A + B) + 1/8 * (C + D)</b> and update the position of the old vertex following <b>(1 - n * u) * original_position + u * original_neighbor_position_sum</b>. I set bool isNew of all existing edges and vertices to be <b>false</b>.</p>
<p>Secondly, I split all the old edges using <b>HalfedgeMesh::splitEdge()</b>. The way I determine whether the edges are old or the newly subdivided is whether two of their vertices both are old. Then, I set the <b>newPosition</b> to the new vertices after splitting and also set <b>bool isNew</b> of these vertices to be <b>true</b>.</p>
<p>Thirdly, I flip the edges that are newly subdivided and one of their two connected vertices are new and one are old using <b>HalfedgeMesh::flipEdge()</b>. I also set <b>bool isNew</b> of these edges to be <b>false</b> in order for the next turn.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6/cube 1.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube 2.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube 3.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube 4.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube 5.jpg" align="middle" width="200px"/>
      </td>
    </tr>
  </table>
</div>

<p>Cube with pre-splitting is smoother and reduce the sharp corners and edges at some degree.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6/cube pre 1.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube pre 2.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube pre 3.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube pre 4.jpg" align="middle" width="200px"/>
      </td>
      <td>
        <img src="images/task6/cube pre 6.jpg" align="middle" width="200px"/>
      </td>
    </tr>
  </table>
</div>

<p>Bean after mesh upsampling.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6/bean 1.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task6/bean 2.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task6/bean 3.jpg" align="middle" width="300px"/>
      </td>
    </tr>
  </table>
</div>

<p>Teapot after mesh upsampling.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6/teapot 1.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task6/teapot 2.jpg" align="middle" width="300px"/>
      </td>
      <td>
        <img src="images/task6/teapot 3.jpg" align="middle" width="300px"/>
      </td>
    </tr>
  </table>
</div>

<p>I have main three bugs when I am implementing the function: </p>
<p>  1.	I didn’t determine whether the edges were old or newly subdivided before I split the edges, causing it runs infinitely. </p>
<p>  2.	I didn’t set all the variables to double or float.</p>
<p>  3.	I didn’t set bool isNew of newly subdivided edges to be true, thus, although when I was going to flip the edges, there weren’t any new edge and nothing was input into <b>HalfedgeMesh::flipEdge()</b>. Therefore, when I run the program, only lines were shown.
</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6/debug.jpg" align="middle" width="900px"/>
        <figcaption align="middle">Bug: Mesh Disappear.</figcaption>
      </td>
    </tr>
  </table>
</div>


</body>
</html>
